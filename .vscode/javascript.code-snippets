{
  "boilerPlates": {
    "prefix": "lambda",
    "body": [
      "import log from '../libs/logs';",
      "import https from '../libs/https';",
      "import { BadRequestError } from '@helsingborg-stad/npm-api-error-handling';",
      "import * as response from '../libs/response';\n",
      "// Interface describing the INPUT data of the function",
      "// This is the data extracted from the AWS event structure,",
      "// either as a whole or as the JSON parsed from the body property.",
      "export interface LambdaRequest {",
      "\tproperty: string;",
      "}\n",
      "// Interface describing the OUTPUT data of the function",
      "// In general, this is the actual response data without any",
      "// envelope needed by AWS.",
      "export interface LambdaResponse {",
      "\tproperty1: string;",
      "\tproperty2: string;",
      "}\n",
      "// Interfaces of external services that are invoked by this function",
      "// Should be known and defined ahead.",
      "export interface ExternalServiceResponse {",
      "\tproperty: string;",
      "}\n",
      "// Interface describing the EXTERNAL DEPENDENCIES used by the function",
      "// This interface will be instantiated differently for",
      "// production and testing mode to allow a wide variety",
      "// of test cases to be executed without dependencies (Such as AWS)",
      "// being available.",
      "//",
      "// NOTE: Instead of declaring a signature manually, you might use the",
      "// typeof operator to assign the signature from another function",
      "export interface Dependencies {",
      "\tmyFunction: (value: string) => string;",
      "\tmyParser: typeof Number.parseInt;",
      "}\n",
      "// The validateRequest function secures that the external data",
      "// provided from the AWS event structure is of the expected format",
      "// This is especially important when user provided data might be",
      "// supplied",
      "function validateRequest(data: LambdaRequest): LambdaRequest {",
      "\tif (data?.property) {",
      "\t\treturn data;",
      "\t}",
      "\tthrow new BadRequestError();",
      "}",
      "// The main function is where the SETUP takes place.",
      "// this is where all pre-requisites for a successfull execution",
      "// is prepared (Such as linking dependencies)",
      "export const main = log.wrap(async event => {",
      "\treturn ${TM_FILENAME_BASE}(event, {",
      "\t\tmyFunction: (value) => value,",
      "\t\tmyParser: Number.parseInt,",
      "\t\t});",
      "});\n",
      "// the '${TM_FILENAME_BASE}' function is where the execution takes place",
      "// Dependencies are either prepared from the main function (production) or",
      "// provide custom handlers from a test case",
      "export async function ${TM_FILENAME_BASE}(event: { body: string }, dependencies: Dependencies) {",
      "\ttry {",
      "\t\tvalidateRequest(JSON.parse(event.body));\n",
      "\t\t// Use the https.request function to invoke external services",
      "\t\tconst externalServiceResponse = await https.request<ExternalServiceResponse>('https://externalservice');\n",
      "\t\t// Prepare response aligned with the LambdaResponse interface",
      "\t\t// In the example, the response is populated from multiple external sources.",
      "\t\tconst data: LambdaResponse = {",
      "\t\t\tproperty1: dependencies.myFunction('value'),",
      "\t\t\tproperty2: externalServiceResponse.property,",
      "\t\t};",
      "\t\treturn response.success(200, data);",
      "\t} catch (error) {",
      "\t\treturn response.failure(error);",
      "\t}",
      "}"
    ]
  }
}
